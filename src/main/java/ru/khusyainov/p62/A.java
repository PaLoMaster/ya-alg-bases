package ru.khusyainov.p62;

import java.util.List;
import java.util.LinkedList;

/**
 * Специи.
 * <p>
 * Вор пробрался в лавку специй и нашел там n видов специй. В его рюкзак можно сложить до W фунтов, поэтому
 * забрать все он не сможет. Предположим, в лавке находится wi фунтов специй с номером i и стоимостью ci долларов.
 * Как унести максимально дорогую добычу? Если вор заберет u1 фунтов специй с номером 1, u2 фунтов специй с номером 2,
 * u3 фунтов специй с номером 3 и т. д., общая ценность украденного составит с1 * u1 / w1 + с2 * u2 / w2 +
 * с3 * u3 / w3 + … сn * un / wn. Вор хотел бы найти максимальное значение этого выражения при следующих ограничениях:
 * ui ≤ wi, u1 + u2 + … + un ≤ W.
 * <ul>
 * <li>стандартный ввод или input.txt:
 * <ul>
 * <li>первая строка ввода содержит n специй и вместимость рюкзака W;</li>
 * <li>следующие n строк указывают цену и вес специй: i-я строка включает в себя цену ci и вес wi i-й специи.</li>
 * </ul>
 * Ограничения: 1 ≤ n ≤ 10^3, 0 ≤ W ≤ 2 * 10^6, 0 ≤ ci ≤ 2 * 10^6, 0 ≤ wi ≤ 2 * 10^6 для всех 1 ≤ i ≤ n.
 * Все числа — целые.</li>
 * <li>стандартный вывод или output.txt: максимальная цена специй, которые вместятся в рюкзак,
 * одно число с точностью до 4го знака.</li>
 * </ul>
 * Хотя ввод для этой задачи и состоит из целых чисел, вывести необходимо нецелое число. Таким образом,
 * абсолютное значение разницы между ответом вашей программы и оптимальным значением не должно превышать 10^−3.
 * Рекомендуем выводить ответ более точно, например, содержащий не меньше четырех цифр в дробной части,
 * иначе даже правильно вычисленный ответ может стать неправильным из-за проблем с округлением.
 */
public class A {
    public static double species(Integer[][] input) {
        List<Integer[]> species = new LinkedList<>(List.of(input));
        species.remove(0);
        species.sort((a1, a2) -> Double.compare(1d * a2[0] / a2[1], 1d * a1[0] / a1[1]));
        return maximumLoot(input[0][1], species);
    }

    private static double maximumLoot(int capacity, List<Integer[]> species) {
        if (capacity == 0 || species.isEmpty()) {
            return 0;
        }
        Integer[] spice = species.remove(0);
        int amount = Math.min(capacity, spice[1]);
        return 1d * spice[0] / spice[1] * amount + maximumLoot(capacity - amount, species);
    }
}
